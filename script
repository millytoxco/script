--local Arguments = loadstring(game:HttpGet("https://raw.githubusercontent.com/v5lr/arguments.lua/refs/heads/main/arguments.lua"))()
--

--

--
----local v5lr = getrawmetatable(game)
  --  local char = v5lr.__namecall
  --  setreadonly(v5lr, false)
  --  v5lr.__namecall = newcclosure(function(...)
  --      local args = {...}
   --     if TargetKeybind and getnamecallmethod() == "FireServer" and args[2] == then
--
   --         if Criv.Hook then
   --             args[3] = v5lrChosenPlayer.Character[Criv.Hook].Position + (v5lrChosenPlayer.Character.Humanoid.MoveDirection * Criv.Hook.Tune)
   --         else
    --            args[3] = v5lrChosenPlayer.Character[Criv.Hook].Position +
     --           (v5lrChosenPlayer.Character[Criv.Hook].Velocity * Criv.Hook.Resolver)
    --        end
     --       return char(unpack(args))
    --   end
    --    return char(...)
   -- end)



if not LPH_OBFUSCATED then
    LPH_JIT_MAX = function(...)
        return (...)
    end
    LPH_NO_VIRTUALIZE = function(...)
        return (...)
    end
end

if not game:IsLoaded() then
    game.Loaded:Wait()
end

-- Global
print 'Global'

-- V #3
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local Camera = workspace.CurrentCamera

local Toggle = false
local Speed = getgenv().Criv['Miscellaneous']['Turn']['Speed'] 
local SpinEnabled = getgenv().Criv['Miscellaneous']['Turn']['Enabled'] 
local Direction = getgenv().Criv['Miscellaneous']['Turn']['Direction'] 

-- Pressing
local function OnKeyPress(Input, GameProcessedEvent)
    if not GameProcessedEvent then
        local keyToToggle = Enum.KeyCode[Direction]
        if keyToToggle and Input.KeyCode == keyToToggle then
            Toggle = not Toggle
        end
    end
end

UserInputService.InputBegan:Connect(OnKeyPress)

local LastRenderTime = 0
local FullCircleRotation = 2 * math.pi
local TotalRotation = 0

-- Main #1
local function RotateCamera()
    if Toggle and SpinEnabled then
        local CurrentTime = tick()
        local TimeDelta = math.min(CurrentTime - LastRenderTime, 0.01)
        LastRenderTime = CurrentTime

        local Rotation = CFrame.fromAxisAngle(Vector3.new(0, 1, 0), math.rad(Speed * TimeDelta))
        Camera.CFrame = Camera.CFrame * Rotation

        TotalRotation = TotalRotation + math.rad(Speed * TimeDelta)
        
        if TotalRotation >= FullCircleRotation then
            Toggle = false 
            TotalRotation = 0 
        end
    end
end

RunService.RenderStepped:Connect(RotateCamera)

-- V
local runService = game:GetService("RunService")
local userInputService = game:GetService("UserInputService")
local playersService = game:GetService("Players")
local workspace = game:GetService("Workspace")
local camera = workspace.CurrentCamera
local localPlayer = playersService.LocalPlayer
local mouse = localPlayer:GetMouse()

local Whiteowls = Drawing.new("Circle")
local fovSettings = getgenv().Criv.Fighting.Silent.fovSettings

Whiteowls.Thickness = fovSettings.Thickness
Whiteowls.Color = fovSettings.Color
Whiteowls.Filled = fovSettings.Filled

local Smokedope2016 = false
local RR = nil

local function updateCircles()
    local guiInsetY = game:GetService("GuiService"):GetGuiInset().Y
    local mousePosition = Vector2.new(mouse.X, mouse.Y + guiInsetY)

    if fovSettings.Visible then
        Whiteowls.Visible = true
        Whiteowls.Radius = fovSettings.FovRadius
        Whiteowls.Position = mousePosition
    else
        Whiteowls.Visible = false
    end
end

runService.RenderStepped:Connect(updateCircles)

local function isDead(player)
    if player.Character and player.Character:FindFirstChild("BodyEffects") then
        local bodyEffects = player.Character.BodyEffects
        local ko = bodyEffects:FindFirstChild("K.O") or bodyEffects:FindFirstChild("KO")
        return ko and ko.Value or false
    end
    return false
end

local function findClosestPlayer()
    local closestPlayer, shortestDistance = nil, math.huge
    local mousePosition = Vector2.new(mouse.X, mouse.Y)

    for _, player in ipairs(playersService:GetPlayers()) do
        if player ~= localPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            local screenPosition, onScreen = camera:WorldToScreenPoint(player.Character.HumanoidRootPart.Position)
            if onScreen then
                local distance = (Vector2.new(screenPosition.X, screenPosition.Y) - mousePosition).Magnitude
                if fovSettings.FovRadius > distance and distance < shortestDistance then
                    closestPlayer, shortestDistance = player, distance
                end
            end
        end
    end
    return closestPlayer
end

local function toggleCamlock(input, processed)
    if processed then return end

    local camlockKey = Enum.KeyCode[getgenv().Criv.Binding.Aiming]
    if input.KeyCode == camlockKey then
        Smokedope2016 = not Smokedope2016

        if Smokedope2016 and getgenv().Criv.Fighting.Aiming.Activate then
            RR = findClosestPlayer()
        else
            RR = nil
        end
    end
end

userInputService.InputBegan:Connect(toggleCamlock)

local function getArgument()
    local currentPlaceId = game.PlaceId
    local eventName, args

    if currentPlaceId == 2788229376 or currentPlaceId == 7213786345 or currentPlaceId == 16033173781 then
        eventName = "MainEvent"
        args = { "UpdateMousePosI2", Vector3.new(-621.6868286132812, 18.75, -117.6417465209961) }
    elseif currentPlaceId == 9825515356 then
        eventName = "MainEvent"
        args = { "MousePosUpdate", Vector3.new(9367.11328125, 547.904541015625, -3346.381103515625) }
    elseif currentPlaceId == 15186202290 or currentPlaceId == 17836920497 or currentPlaceId == 17403265390 then
        eventName = "MAINEVENT"
        args = { "MOUSE", Vector3.new(-105.59376525878906, 11.003229141235352, 127.97737884521484) }
    else
        eventName = "UpdateMousePosI2"
        args = { "MousePosUpdate", Vector3.new(-134.94320678710938, 21.908273696899414, -769.0164794921875) }
    end

    return eventName, args
end

print 'Detection #1'

local function getVelocity(player, partName)
    local part = player.Character and player.Character:FindFirstChild(partName)
    return part and part.Velocity or Vector3.new()
end

local function handleCamlock()
    if Smokedope2016 and RR and RR.Character and not isDead(RR) then
        local settings = getgenv().Criv.Fighting.Aiming
        local hitPartName = settings.TargetParts
        local targetPart = RR.Character:FindFirstChild(hitPartName)

        if targetPart then
            local targetVelocity = getVelocity(RR, hitPartName)
            local predictedPosition = targetPart.Position + targetVelocity * settings.Prediction
            local targetCFrame = CFrame.new(camera.CFrame.Position, predictedPosition)

            camera.CFrame = camera.CFrame:Lerp(targetCFrame, settings.CameraSmoothness)
        end
    else
        RR = nil
    end
end

runService.RenderStepped:Connect(handleCamlock)

local function onToolEquipped(tool)
    
end

local function connectToolEvents()
    for _, tool in ipairs(localPlayer.Backpack:GetChildren()) do
        if tool:IsA("Tool") then
            onToolEquipped(tool)
        end
    end

    localPlayer.Backpack.ChildAdded:Connect(function(child)
        if child:IsA("Tool") then
            onToolEquipped(child)
        end
    end)
end

connectToolEvents()

local function onCharacterAdded(character)
    character.ChildAdded:Connect(function(child)
        if child:IsA("Tool") then
            onToolEquipped(child)
        end
    end)

    for _, tool in pairs(character:GetChildren()) do
        if tool:IsA("Tool") then
            onToolEquipped(tool)
        end
    end

    RR = nil 
end

localPlayer.CharacterAdded:Connect(onCharacterAdded)
if localPlayer.Character then
    onCharacterAdded(localPlayer.Character)
end

if getgenv().Criv['Intro'].Activated then

  
    local imageId = "rbxassetid://120385639213918" 
     local soundId = "rbxassetid://78573915936972" 

    local sound = Instance.new("Sound", game.Workspace)
    sound.SoundId = soundId
    sound:Play()

    local introGui = Instance.new("ScreenGui", localPlayer.PlayerGui)
    local introFrame = Instance.new("Frame", introGui)
    introFrame.Size = UDim2.new(1, 0, 1, 0)
    introFrame.BackgroundColor3 = Color3.new(0, 0, 0)

    local introImage = Instance.new("ImageLabel", introFrame)
    introImage.Size = UDim2.new(1, 0, 1, 0)
    introImage.Image = imageId
    introImage.BackgroundTransparency = 1

    for i = 0, 1, 0.01 do
        introFrame.BackgroundTransparency = i
        wait(0.01)
    end

    wait(2)

    for i = 1, 0, -0.01 do
        introFrame.BackgroundTransparency = i
        wait(0.01)
    end

    introGui:Destroy()
end

local VirtualInputManager = game:GetService("VirtualInputManager")
local runService = game:GetService("RunService")
local userInputService = game:GetService("UserInputService")

local function handleMacroSpeedGlitch()
    local settings = getgenv().Criv.Macro
    local interval = settings.Speed

    if settings.Activated then 
        local function onMacroInput(input, processed)
            if processed then return end

            if input.KeyCode == Enum.KeyCode[settings.Keybind] then
                settings.Enabled = not settings.Enabled 
                --
                if settings.Enabled then 
                    if settings.Mode == "FirstPerson" then
                        local nextActionTime = tick() + interval

                        repeat
                            if tick() >= nextActionTime then
                                VirtualInputManager:SendMouseWheelEvent(0, 0, true, game)
                                runService.Heartbeat:Wait()
                                VirtualInputManager:SendMouseWheelEvent(0, 0, false, game)
                                nextActionTime = tick() + interval
                            end
                            runService.Heartbeat:Wait()
                        until not settings.Enabled -- handling (.)_(.)
                        --
                    elseif settings.Mode == "ThirdPerson" then
                        local actionInterval = interval / 4
                        local nextActionTime = tick() + actionInterval

                        repeat
                            if tick() >= nextActionTime then
                                VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.I, false, game)
                                nextActionTime = tick() + actionInterval
                            end
                            runService.Heartbeat:Wait()

                            if tick() >= nextActionTime then
                                VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.O, false, game)
                                nextActionTime = tick() + actionInterval
                            end
                            runService.Heartbeat:Wait()

                            if tick() >= nextActionTime then
                                VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.I, false, game)
                                nextActionTime = tick() + actionInterval
                            end
                            runService.Heartbeat:Wait()

                            if tick() >= nextActionTime then
                                VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.O, false, game)
                                nextActionTime = tick() + actionInterval
                            end
                            runService.Heartbeat:Wait()

                        until not settings.Enabled 
                    end
                end
            end
        end
        userInputService.InputBegan:Connect(onMacroInput)
    end
end

handleMacroSpeedGlitch()

local DotFOV = getgenv().Criv.Fighting.Silent.DotFOV

local RunService = game:GetService('RunService')
local Players = game:GetService("Players")
local Client = Players.LocalPlayer
local Mouse = Client:GetMouse()
local GuiS = game:GetService("GuiService")

local MainDot = Drawing.new("Circle")
MainDot.Visible = false
MainDot.Transparency = 0
MainDot.Radius = 0.1
MainDot.Thickness = 0.1
MainDot.Color = DotFOV.Color

local MainFOV = Drawing.new("Circle")
MainFOV.Visible = DotFOV.Visible
MainFOV.Transparency = DotFOV.Transparency
MainFOV.Radius = DotFOV.Radius
MainFOV.Thickness = DotFOV.Thickness
MainFOV.Color = DotFOV.Color

local NumDots = DotFOV.Num_Dots
local DottedSize = DotFOV.Dotted_Size
local angleIncrement = 360 / NumDots
local MiniDots = {}

local function getColorFromRainbow(offset)
    local r = math.sin(offset * math.pi) * 127 + 128
    local g = math.sin(offset * math.pi + 2 * math.pi / 3) * 127 + 128
    local b = math.sin(offset * math.pi + 4 * math.pi / 3) * 127 + 128
    return Color3.fromRGB(r, g, b)
end

for i = 1, NumDots do
    local MiniDot = Drawing.new("Circle")
    MiniDot.Visible = DotFOV.ShowMiniDot
    MiniDot.Filled = true
    MiniDot.Transparency = 1
    MiniDot.Radius = DottedSize
    MiniDot.Thickness = 1
    table.insert(MiniDots, MiniDot)
end

RunService.Heartbeat:Connect(function()
    MainFOV.Visible = DotFOV.Visible
    MainFOV.Transparency = DotFOV.Transparency
    MainFOV.Radius = DotFOV.Radius
    MainFOV.Thickness = DotFOV.Thickness
    MainFOV.Color = DotFOV.Color
    
    local guiInsetY = GuiS:GetGuiInset().Y
    MainDot.Position = Vector2.new(Mouse.X, Mouse.Y + guiInsetY)
    MainFOV.Position = Vector2.new(Mouse.X, Mouse.Y + guiInsetY)
    local Radius = DotFOV.Radius
    
    for i, miniDot in ipairs(MiniDots) do
        local angle = math.rad((i - 1) / NumDots * 360)
        local offsetX = math.cos(angle) * Radius
        local offsetY = math.sin(angle) * Radius
        miniDot.Position = MainDot.Position + Vector2.new(offsetX, offsetY)
        
        if DotFOV.Rainbow then
            miniDot.Color = getColorFromRainbow(i / NumDots)
        else
            miniDot.Color = DotFOV.Color
        end
    end
end)

spawn(function()
    while DotFOV.Rainbow do
        for i = 1, 50 do
            DotFOV.Num_Dots = i
            wait(math.random(1, 2) / 100)
        end
    end
end)

-- V #2
local Inset = game:GetService("GuiService"):GetGuiInset().Y
local Mouse = game.Players.LocalPlayer:GetMouse()
local Client = game.Players.LocalPlayer
local Cam = workspace.CurrentCamera
local RunService = game:GetService("RunService")

local FOV = Drawing.new("Circle")
local fovSettings = Criv.Fighting.Silent.fovSettings

FOV.Thickness = fovSettings.Thickness
FOV.Color = fovSettings.Color
FOV.Filled = fovSettings.Filled

local function UpdateFOV()
    if fovSettings.Visible then
        FOV.Position = Vector2.new(Mouse.X, Mouse.Y + Inset)
        FOV.Radius = fovSettings.FovRadius
        FOV.Visible = true
    else
        FOV.Visible = false
    end
end

local function WallCheck(destination, ignore)
    if not Criv.Miscellaneous.Checks.WallCheck then
        return true
    end
    local origin = Cam.CFrame.p
    local direction = (destination - origin).unit * 100  
    local ray = Ray.new(origin, direction)
    local hit = workspace:FindPartOnRayWithIgnoreList(ray, ignore)
    return hit == nil
end

local function Death(Plr)
    if Plr.Character and Plr.Character:FindFirstChild("BodyEffects") then
        local bodyEffects = Plr.Character.BodyEffects
        local ko = bodyEffects:FindFirstChild("K.O") or bodyEffects:FindFirstChild("KO")
        return ko and ko.Value
    end
    return false
end

function DetectionFunction(detection)
    if detection then
        print('Arguments Detected')
    end
end

DetectionFunction(true) -- global )_<

print (game.PlaceId)

local function getEventName()
    local placeIds = {
        [2788229376] = "UpdateMousePosI2",
        [7213786345] = "UpdateMousePosI2",
        [16033173781] = "UpdateMousePosI2",
        [9825515356] = "MousePosUpdate",
        [17897702920] = "UpdateMousePos",
        [15644861772] = "UpdateMousePos",
        [125825216602676] = "MOUSE",
        [122094140167766] = "MOUSE",
        [138831788033519] = "MOUSE", 
        [15186202290] = "MOUSE",
    }
    return placeIds[game.PlaceId] or "UpdateMousePosI2"
end

local function getEventName()
    local placeIds = {
        [17344804827] = "UpdateMousePosI2",
        [14277620939] = "UpdateMousePosI2",
        [16033173781] = "UpdateMousePosI2",
        [9825515356] = "MousePosUpdate",
        [17897702920] = "UpdateMousePos",
        [15644861772] = "UpdateMousePos",
        [125825216602676] = "MOUSE",
        [122094140167766] = "MOUSE",
        [138831788033519] = "MOUSE", 
        [15186202290] = "MOUSE",
        [17344804827] = "UpdateMousePos",
        [14277620939] = "UpdateMousePos",
        [18710690149] = "UpdateMousePos",
        [17787524861] = "UpdateMousePos",
        [17787524861] = "UpdateMousePos",
        [2788229376] = "UpdateMousePosI2",
        [5081773298] = "UpdateMousePos",
        [107695061804464] = "UpdateMousePos",
		[5602055394] = "UpdateMousePos",
    }
    return placeIds[game.PlaceId] or "UpdateMousePosI2"
end
print 'Detection #2'

local Argument = 138831788033519
local Argument = 15186202290
local Argument = 122094140167766
local Argument = 125825216602676

if game.PlaceId == Argument then
    print("Detected target place ID: " .. Argument)
else
    print("Argument Detected")
end


local function MainEvents()
    local eventNames = {
        "MainEvent",
        "MAINEVENT",
        "Bullets",
        ".gg/untitledhood",
    }
    for _, child in pairs(game.ReplicatedStorage:GetChildren()) do
        for _, eventName in pairs(eventNames) do
            if child.Name == eventName then
                return child
            end
        end
    end
end

local function getClosestChar()
    local target, closestDist = nil, math.huge
    local mousePos = Vector2.new(Mouse.X, Mouse.Y)

    for _, v in pairs(game.Players:GetPlayers()) do
        if v.Character and v ~= Client and v.Character:FindFirstChild("HumanoidRootPart") then
            if Criv.Fighting.Silent.KOcheck and Death(v) then
                continue
            end

            local closestPart, closestPartDistance = nil, math.huge
            local partsToCheck = Criv.Fighting.Silent.MultipleParts

            for _, partName in pairs(partsToCheck) do
                local part = v.Character:FindFirstChild(partName)
                if part then
                    local partPos = Cam:WorldToScreenPoint(part.Position)
                    local distance = (Vector2.new(partPos.X, partPos.Y) - mousePos).Magnitude
                    if distance < closestPartDistance and distance < Criv.Fighting.Silent.fovSettings.FovRadius and WallCheck(part.Position, {Client, v.Character}) then
                        closestPartDistance = distance
                        closestPart = part
                    end
                end
            end

            if closestPart and closestPartDistance < closestDist then
                closestDist = closestPartDistance
                target = {Player = v, Part = closestPart}
            end
        end
    end
    return target
end

local function connectToolActivation(tool)
    if tool:IsA("Tool") then
        local debounce = false
        tool.Activated:Connect(function()
            if not debounce then
                debounce = true
                if Criv.Fighting.Silent.Activated then
                    local target = getClosestChar()
                    if target then
                        local endPoint = target.Part.Position + (target.Part.Velocity * Criv.Fighting.Silent.Prediction)
                        MainEvents():FireServer(getEventName(), endPoint)
                    end
                end
                task.wait(0.1)
                debounce = false
            end
        end)
    end
end

local function setupToolConnections()
    for _, tool in pairs(Client.Backpack:GetChildren()) do
        connectToolActivation(tool)
    end

    Client.Backpack.ChildAdded:Connect(function(tool)
        connectToolActivation(tool)
    end)
end

local function handleRespawn()
    task.wait(1)

    Cam = workspace.CurrentCamera
    Mouse = Client:GetMouse()

    setupToolConnections()

    FOV.Thickness = fovSettings.Thickness
    FOV.Color = fovSettings.Color
    FOV.Filled = fovSettings.Filled

    RunService.RenderStepped:Connect(function()
        UpdateFOV()
    end)
end

local function setupRespawnHandling()
    Client.CharacterAdded:Connect(function()
        handleRespawn()
    end)
end

handleRespawn()
setupRespawnHandling()

print 'Detection #3 Script Loaded'
